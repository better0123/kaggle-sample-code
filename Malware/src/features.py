from FileReader import FileReader
import sys, glob, os.path, zlib
import numpy, numpy.random, numpy.linalg
import argparse
import itertools
from nltk.util import ngrams

HEX_CHARS                   = set('1234567890ABCDEF')
HEX_2DIGITS                 = set( ('%02x' % i).upper()  for i in xrange(0, 256)) 
DEFAULT_BLACKLIST           = [' dd ',' dw ',' db ']
NORM_HASH_ROUNDING_DECIMALS = 5
EPSILON                     = numpy.finfo(float).eps
RANDOM_SEED                 = 42


def hashFeatures(iterable, n_features, use_sign_hash=True):
    vec = numpy.zeros(n_features, dtype=int)
    for hashable_item in iterable:
        h = hash(hashable_item) % n_features
        neg_sign = zlib.adler32(hashable_item) % 2 == 0 
        if use_sign_hash and neg_sign:
            vec[h] -= 1
        else:
            vec[h] += 1
    return vec

def normHashFeatures(vec, norm_dim):
    if norm_dim:
        norm = numpy.linalg.norm(vec, ord=norm_dim) + EPSILON 
        normVec = vec.astype(float) / norm
        roundNormVec = numpy.around(normVec, decimals=NORM_HASH_ROUNDING_DECIMALS)
        return roundNormVec
    else:
        return vec

def anyStringInLine(strings, line):
    for string in strings:
        if string in line:
            return True
    return False

def skipThisLine(tokens, cmdlineArgs):
        if len(tokens) < 2: 
            return True

        line = ' '.join(tokens)
        whitelist = cmdlineArgs.whiteliststrings 
        blacklist = cmdlineArgs.blackliststrings

        if whitelist:
            if anyStringInLine(whitelist, line): 
                return False
            else:
                return True

        if blacklist:
            if anyStringInLine(blacklist, line): 
                return True
            else:
                return False

        return False

def asmFirstBytesNGramsIter(asmFile, ngram_len, cmdlineArgs):
    firstBytes = [] 
    for tokens in asmFile.linetokens():
        if skipThisLine(tokens, cmdlineArgs):
            continue
        if tokens[1] in HEX_2DIGITS:
            firstBytes.append(tokens[1])

    firstBytesUniq = (b[0] for b in itertools.groupby(firstBytes))
    for ngram in ngrams(firstBytesUniq, ngram_len):
        if cmdlineArgs.bytengramsort:
            ngram_str = ' '.join(sorted(ngram))
        else:
            ngram_str = ' '.join(ngram)
        yield ngram_str

def asmFirstByteNGramsHash(asmFile, bytesFile, cmdlineArgs):
    hashVec = hashFeatures( \
                asmFirstBytesNGramsIter(asmFile, cmdlineArgs.bytengramlen, cmdlineArgs), \
                cmdlineArgs.bytehashdim, \
                use_sign_hash = cmdlineArgs.bytehashsigned \
              )
    normHashVec = normHashFeatures(hashVec, cmdlineArgs.bytehashnorm)
    return {'asm1ByteNGhash_{0:0>4}'.format(ix) : h for ix, h in enumerate(normHashVec) }

def asmOpcodesIter(asmFile, cmdlineArgs):
    for tokens in asmFile.linetokens():
        if skipThisLine(tokens, cmdlineArgs):
            continue
        opcode_no2hex = ' '.join(t for t in tokens[1:] if t not in HEX_2DIGITS)
        opcode_nohex  = ''.join( c for c in opcode_no2hex if c not in HEX_CHARS)
        yield opcode_nohex

def asmOpcodesHash(asmFile, bytesFile, cmdlineArgs):
    hashVec = hashFeatures( asmOpcodesIter(asmFile, cmdlineArgs), \
                            cmdlineArgs.asmhashdim, \
                            use_sign_hash = cmdlineArgs.asmhashsigned \
              )
    normHashVec = normHashFeatures(hashVec, cmdlineArgs.asmhashnorm)
    return {'asmOpHash_{0:0>4}'.format(ix) : h for ix, h in enumerate(normHashVec) }

def malwareId(asmFile, bytesFile, cmdlineArgs):
    assert asmFile.Id() == bytesFile.Id()
    return { 'Id':asmFile.Id() }

def fileLengths(asmFile, bytesFile, cmdlineArgs):
    lenASM   = len(asmFile.string())
    lenBytes = len(bytesFile.string())
    fileCompressRatioASM   = len(zlib.compress(asmFile.string()  )) / float(lenASM)
    fileCompressRatioBytes = len(zlib.compress(bytesFile.string())) / float(lenBytes)
    return {    'fileLenASM'        : lenASM, 
                'fileLenBytes'      : lenBytes,
                'fileCmpRatioASM'   : fileCompressRatioASM,
                'fileCmpRatioBytes' : fileCompressRatioBytes  }

def randomFeatures(asmFile, bytesFile, cmdlineArgs):
    norm_rands = numpy.random.randn(cmdlineArgs.nrandf)
    return {'randNorm_{0:0>2}'.format(ix) : r for ix, r in enumerate(norm_rands) }

def collectFeatures(asmFile, bytesFile, cmdlineArgs):
    # NOTE define the list of feature functions to use below !! NOTE
    featureFuncs = [    malwareId, \
                        asmOpcodesHash, \
                        asmFirstByteNGramsHash, \
                        fileLengths, \
                        randomFeatures
                   ]  
    features = {}
    for featureFunc in featureFuncs:
        features.update( featureFunc(asmFile, bytesFile, cmdlineArgs) )
    return features

def mainLoop(cmdlineArgs):
    featureFile = open(cmdlineArgs.featureFileName,'w')
    wroteHeader = False
    headerFeatureNames = None

    asmFileNames = sorted(glob.glob(cmdlineArgs.malwareDir+ '/*.asm'))
    for n, asmFileName in enumerate(asmFileNames, start=1):

        asmFile   = FileReader(asmFileName)
        bytesFile = FileReader(cmdlineArgs.malwareDir + '/' + asmFile.Id() + '.bytes')
        print "Processing Id: {} ({} of {})".format(asmFile.Id(), n, len(asmFileNames))
        features = collectFeatures(asmFile, bytesFile, cmdlineArgs)

        if not wroteHeader:
            headerFeatureNames = list(sorted(features))
            header = ','.join(str(featureName) for featureName 
                                               in headerFeatureNames)
            featureFile.write(header + '\n')
            wroteHeader = True

        outstring = ','.join( str(features[featureName]) for featureName 
                                                         in headerFeatureNames)
        featureFile.write(outstring + '\n')

    featureFile.close()
    print "\nDone. Wrote features to : ", cmdlineArgs.featureFileName, "\n"

def parseCommandLine():
    parser = argparse.ArgumentParser()
    parser.add_argument("malwareDir",     type=str, 
                        help="Dir containing .asm & .bytes files")
    parser.add_argument("featureFileName",   type=str, 
                        help="Filename to write features to")

    parser.add_argument("--asmhashdim", type=int, default=1, 
                        help="Hashing trick dimension for .asm opcode lines")
    parser.add_argument("--bytehashdim",   type=int, default=1, 
                        help="Hashing trick dim of Ngram of first optcode bytes")
    parser.add_argument("--bytengramlen",   type=int, default=1, 
                        help="Length of Ngram of first opcode bytes")
    parser.add_argument("--bytengramsort",  action="store_true", 
                        help="Sort tokens within ngram.")

    parser.add_argument("--asmhashnorm",   type=int, default=0, choices=[0,1,2], 
                        help="Normalization option for .asm hash features")
    parser.add_argument("--bytehashnorm",   type=int, default=0, choices=[0,1,2], 
                        help="Normalization option for first opcode byte hash features")

    parser.add_argument("--asmhashsigned",   action="store_true", 
                        help="Use sign hash in hashing trick for .asm opcode features")
    parser.add_argument("--bytehashsigned",  action="store_true", 
                        help="Use sign hash in hashing trick for first-byte/Ngram features ")

    parser.add_argument("--whiteliststrings",  nargs='*', 
                        help="Substrings that will force an asm line to be incuded  (excludes others).")
    parser.add_argument("--blackliststrings",  nargs='*', default=DEFAULT_BLACKLIST,
                        help="Substrings that will force an asm line to be excluded (includes others).")

    parser.add_argument("--nrandf",  type=int, default=1, 
                        help="Number of random features")

    args = parser.parse_args()
    print "\n*** Feature Generation from Malware Files ***\n"
    print "Input malware dir    : {}".format(args.malwareDir)
    print "Feature file         : {}".format(args.featureFileName)
    print "ASM hash dim         : {}".format(args.asmhashdim)
    print "Byte hash dim        : {}".format(args.bytehashdim)
    print "Byte ngram length    : {}".format(args.bytengramlen)
    print "Byte ngram sort      : {}".format(args.bytengramsort)
    print "ASM hash count norm  : {}".format(args.asmhashnorm)
    print "Byte hash count norm : {}".format(args.bytehashnorm)
    print "ASM hash signed      : {}".format(args.asmhashsigned)
    print "Byte hash signed     : {}".format(args.bytehashsigned)
    print "Whitelist asm strings: {}".format(args.whiteliststrings)
    print "Blacklist asm strings: {}".format(args.blackliststrings)
    print "Random features      : {}".format(args.nrandf)
    print
    print "Command line was:\n",  ' '.join(sys.argv), "\n"
    return args

if __name__ == '__main__':
    numpy.random.seed(seed=RANDOM_SEED)
    mainLoop(parseCommandLine())

